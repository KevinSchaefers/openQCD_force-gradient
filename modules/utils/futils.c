/*******************************************************************************
*
* File futils.c
*
* Copyright (C) 2020, 2022 Martin Luescher
*
* This software is distributed under the terms of the GNU General Public
* License (GPL)
*
* Utility programs for the status arrays in force and related programs.
*
*   int *alloc_std_status(void)
*     Allocates an integer array of standard size NSTD_STATUS and returns
*     its address.
*
*   void reset_std_status(int *status)
*     Sets the status array to zero assuming the array has the standard
*     size.
*
*   void acc_std_status(char *solver,int *ifail,int *sval,int io,int *status)
*     Adds the status values sval returned by the specified solver program
*     to the status array at offset 0 if io=0 and at offset NSTD_STATUS/2
*     otherwise. The array status is assumed to have the standard size and
*     the values sval are added only if the solver succeeded according to
*     the failure flags ifail.
*
*   void add_std_status(int *new,int *status)
*     Adds the contents of the array new to the status array assuming both
*     arrays have the standard length.
*
*   void avg_std_status(int ns,int *status)
*     Divides the values in the status array (except for its last element)
*     by ns if ns>0 and otherwise leaves the values unchanged. The array is
*     assumed to have the standard length and the division is rounded to the
*     next integer.
*
*   void print_std_status(char *solver1,char *solver2,int *status)
*     Prints the values contained in the array status to stdout on MPI
*     process 0, assuming they were produced by the specified solver
*     programs and added to the array by acc_std_status(). If solver1
*     or solver2 is set to NULL, that solver is ignored and only the
*     status values produced by the other solver are printed.
*
*   void print_status(char *program,int *ifail,int *sval)
*     Prints the failure indicators ifail and status values sval produced
*     by the specified program to stdout on MPI process 0 in a format that
*     should be self-explanatory.
*
* Standard status arrays are fixed-length integer arrays passed to the force
* and related programs. Their size NSTD_STATUS is an odd integer defined in
* utils.h. On exit the arrays contain the following:
*
*   status[k]      k=0,..,(NSTD_STATUS/2)-1. Status values returned
*                  by the first solver called in the program.
*
*   status[k]      k=NSTD_STATUS/2,..,2*(NSTD_STATUS/2)-1. Status
*                  values returned by the second solver called in
*                  the program.
*
*   status[k]      k=NSTD_STATUS-1. Number of times the deflation
*                  subspace was regenerated.
*
* Any unused array elements are set to zero. The known solver programs are
*
*   dfl_sap_gcr, dfl_sap_gcr2, sap_gcr, tmcg, tmcgeo, tmcgm.
*
* The programs known to print_status() include all these plus the mode
* generation programs
*
*   dfl_modes, dfl_modes2, dfl_update, dfl_update2.
*
* When the solver program regenerated the deflation modes, and if it was
* successful, acc_std_status() adds the second set of status values to the
* output array and increases status[-1] by 1.
*
* The program print_std_status() pretty-prints the status numbers on one
* line in different forms like
*
*  67
*  67;89
*  28[3|12]
*
* for example, according to the following rules:
*
* - For the deflated solvers, the output is of the form n0 [n1|n2], where
*   n0 is the number of Krylov vectors generated by the fgcr solver, while
*   n1 and n2 are the average numbers of Krylov vectors generated by the
*   fgcr4vd solver and gcr4v preconditioner of the little Dirac equation.
*
* - In all other cases, the iteration number is printed.
*
* - If there are two solvers, their status numbers are separated by a
*   semicolon ";".
*
* - A message "(deflation subspace regenerations = <int>)" is appended,
*   if the deflation subspace had to be regenerated.
*
* The form of the output coincides with the one used in the main simulation
* programs.
*
* The programs in this module are assumed to be called by the OpenMP master
* thread on any MPI process.
*
*******************************************************************************/

#define FUTILS_C

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include "mpi.h"
#include "utils.h"


int *alloc_std_status(void)
{
   int k,*status;

   status=malloc(NSTD_STATUS*sizeof(*status));
   error_loc(status==NULL,1,"alloc_status [futils.c]",
             "Unable to allocate status array");

   for (k=0;k<NSTD_STATUS;k++)
      status[k]=0;

   return status;
}


void reset_std_status(int *status)
{
   int k;

   for (k=0;k<NSTD_STATUS;k++)
      status[k]=0;
}


void acc_std_status(char *solver,int *ifail,int *sval,int io,int *status)
{
   int n,k;

   n=NSTD_STATUS/2;
   if (io!=0)
      io=n;

   if (strcmp(solver,"dfl_sap_gcr2")==0)
   {
      if ((ifail[0]>=-2)&&(ifail[1]==0))
      {
         if (ifail[0]<0)
         {
            for (k=0;k<n;k++)
               status[io+k]+=sval[n+k];
            status[NSTD_STATUS-1]+=1;
         }
         else
         {
            for (k=0;k<n;k++)
               status[io+k]+=sval[k];
         }
      }
   }
   else if (ifail[0]==0)
   {
      if (strcmp(solver,"dfl_sap_gcr")==0)
      {
         for (k=0;k<n;k++)
            status[io+k]+=sval[k];
      }
      else
         status[io]+=sval[0];
   }
}


void add_std_status(int *new,int *status)
{
   int k;

   for (k=0;k<NSTD_STATUS;k++)
      status[k]+=new[k];
}


void avg_std_status(int ns,int *status)
{
   int k;

   if (ns>0)
   {
      for (k=0;k<(NSTD_STATUS-1);k++)
         status[k]=(status[k]+(ns/2))/ns;
   }
}


void print_std_status(char *solver1,char *solver2,int *status)
{
   int my_rank,k,*stat;
   char *solver;

   MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);

   if ((my_rank==0)&&((solver1!=NULL)||(solver2!=NULL)))
   {
      printf("status = ");

      for (k=0;k<2;k++)
      {
         if (k==0)
         {
            stat=status;
            solver=solver1;
         }
         else
         {
            stat=status+(NSTD_STATUS/2);
            solver=solver2;

            if ((solver1!=NULL)&&(solver2!=NULL))
               printf(";");
         }

         if (solver!=NULL)
         {
            if ((strcmp(solver,"dfl_sap_gcr2")==0)||
                (strcmp(solver,"dfl_sap_gcr")==0))
               printf("%d[%d|%d]",stat[0],stat[1],stat[2]);
            else
               printf("%d",stat[0]);
         }
      }

      if (status[NSTD_STATUS-1])
         printf(" (deflation subspace regenerations = %d)\n",
                status[NSTD_STATUS-1]);
      else
         printf("\n");
   }
}


void print_status(char *program,int *ifail,int *sval)
{
   int my_rank;

   MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);

   if (my_rank==0)
   {
      if ((strcmp(program,"tmcg")==0)||
          (strcmp(program,"tmcgeo")==0)||
          (strcmp(program,"tmcgm")==0)||
          (strcmp(program,"sap_gcr")==0))
      {
         printf("ifail=%d, status=%d",ifail[0],sval[0]);
      }
      else if (strcmp(program,"dfl_sap_gcr2")==0)
      {
         printf("ifail=%d, status=%d, status(fgcr4vd)=%d, "
                "status(gcr4v)=%d",ifail[0],sval[0],sval[1],sval[2]);

         if ((ifail[0]==-1)||(ifail[0]==-2))
            printf("; ifail=%d, status=%d, status(fgcr4vd)=%d, "
                   "status(gcr4v)=%d",ifail[1],sval[3],sval[4],sval[5]);
      }
      else if (strcmp(program,"dfl_sap_gcr")==0)
      {
         printf("ifail=%d, status=%d, status(fgcr4vd)=%d, "
                "status(gcr4v)=%d",ifail[0],sval[0],sval[1],sval[2]);
      }
      else if ((strcmp(program,"dfl_modes2")==0)||
               (strcmp(program,"dfl_update2")==0))
      {
         printf("ifail=%d, status(fgcr4vd)=%d, status(gcr4v)=%d",
                ifail[0],sval[0],sval[1]);

         if (ifail[0]==-2)
         {
            printf("; ifail=%d, status(fgcr4vd)=%d, status(gcr4v)=%d",
                   ifail[1],sval[2],sval[3]);
         }
      }
      else if ((strcmp(program,"dfl_modes")==0)||
               (strcmp(program,"dfl_update")==0))
      {
         printf("ifail=%d, status(fgcr4vd)=%d, status(gcr4v)=%d",
                ifail[0],sval[0],sval[1]);
      }
      else
         error_root(1,1,"print_status [futils.c]","Unknown program");

      printf("\n");
   }
}
