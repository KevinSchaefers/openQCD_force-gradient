
/*******************************************************************************
*
* File dfl_modes.c
*
* Copyright (C) 2007-2013, 2018, 2021 Martin Luescher
*
* This software is distributed under the terms of the GNU General Public
* License (GPL)
*
* Computation of the global modes used to construct the deflation subspace.
*
*   void dfl_modes(int *ifail,int *status)
*     Computes the basis vectors of the deflation subspace by applying a
*     smoothing procedure to a set of random fields. The subspace is then
*     initialized by calling the program dfl_subspace().
*
*   void dfl_modes2(int *ifail,int *status)
*     Calls dfl_modes() and, if ifail[0]=-2, calls dfl_modes() a second
*     time.

*   void dfl_update(int nsm,int *ifail,int *status)
*     Updates the deflation subspace by applying nsm deflated smoothing
*     steps to the global fields from which the current subspace was built.
*
*   void dfl_update2(int nsm,int *ifail,int *status)
*     Calls dfl_update() and, if ifail[0]=-2, calls dfl_modes().
*
* The deflation subspace is generated by inverse iteration and projection
* to the basis fields in the DFL_BLOCKS grid. See
*
*  M. Luescher: "Local coherence and deflation of the low quark modes
*                in lattice QCD", JHEP 0707 (2007) 081, and
*
*               "Deflation acceleration of lattice QCD simulations",
*               JHEP 0712 (2007) 011.
*
* The following parameter-setting programs must have been called before
* launching the programs in this module:
*
*  set_lat_parms()        SW improvement coefficient.
*
*  set_bc_parms()         Boundary conditions and associated improvement
*                         coefficients.
*
*  set_sap_parms()        Block size of the SAP block grid.
*
*  set_dfl_parms()        Parameters of the deflation subspace.
*
*  set_dfl_pro_parms()    Deflation projection parameters.
*
*  set_dfl_gen_parms()    Subspace generation parameters.
*
* See doc/parms.pdf and the relevant files in the modules/flags directory
* for further explanations. The update programs moreover assume that the
* current deflation subspace was previously initialized using dfl_modes()
* or dfl_modes2().
*
* The inverse iteration starts with a few applications of the Schwarz (SAP)
* preconditioner (see sap/sap.c). Later the modes are deflated, using the
* current deflation subspace generated by them, before the SAP is applied.
*
* The parameters of this process set by set_dfl_gen_parms() are
*
*  kappa          Hopping parameter of the Dirac operator.
*
*  mu             Twisted mass parameter.
*
*  ninv           Total number of inverse iteration steps (ninv>=4).
*
*  nmr            Number of block minimal residual iterations to be
*                 used when the SAP smoother is applied.
*
*  ncy            Number of SAP cycles per inverse iteration.
*
* The Dirac operator used in the inverse iteration is
*
*  D=Dw+i*mu*gamma5*1e,  1e:projector to the even lattice sites,
*
* while the SW-term is determined by the bare mass m0=1/(2*kappa)-4 and the
* value of the SW-coefficient csw retrieved from the parameter data base.
*
* In the case of the programs dfl_modes() and dfl_update(), the arrays ifail
* and status must have 1 and 2 (or more) elements. On exit
*
*  ifail[0]=0     The program completed successfully.
*
*  ifail[0]=-2    The inversion of the diagonal parts of the little
*                 Dirac operator was not safe.
*
*  ifail[0]=-3    The inversion of the SW term on the odd sites of
*                 the lattice was not safe.
*
*  status[0]      Average number of Krylov vectors generated by the
*                 fgcr4vd() algorithm used in the solver for the little
*                 Dirac equation (see ltl_gcr.c).
*
*  status[1]      Average number of Krylov vectors generated by the
*                 gcr4v() preconditioner used in the solver for the
*                 little Dirac equation (see ltl_gcr.c).
*
* In the case of the programs dfl_modes2() and dfl_update2(), ifail and
* status must have at least 2 and 4 elements, respectively, the second
* half of the arrays being reserved for the output of the second call in
* in these programs (the values are set to zero if there was none).
*
* The programs dfl_modes2() and dfl_update2() can be used in place of the
* programs dfl_modes() and dfl_update(), respectively, if some protection
* against the rare cases, where the little Dirac operator turns out to be
* accidentally ill-conditioned, is desired.
*
* The programs in this module are assumed to be called by the OpenMP master
* thread on all MPI processes simultaneously. The required workspaces are
*
*  spinor              Ns+2   (Ns: number of deflation modes per block)
*  complex             2*dpr.nmx_gcr+3
*  complex_dble        2*dpr.nkv+4
*
* where dpr.nmx_gcr and dpr.nkv are parameters of the solver for the little
* Dirac equation (see utils/wspace.c and flags/dfl_parms.c).
*
* Some debugging output is printed to stdout on process 0 if DFL_MODES_DBG
* is defined at compilation time.
*
*******************************************************************************/

#define DFL_MODES_C

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <omp.h>
#include "mpi.h"
#include "utils.h"
#include "flags.h"
#include "random.h"
#include "lattice.h"
#include "block.h"
#include "uflds.h"
#include "sflds.h"
#include "vflds.h"
#include "linalg.h"
#include "sw_term.h"
#include "dirac.h"
#include "sap.h"
#include "little.h"
#include "dfl.h"
#include "global.h"

typedef union
{
   spinor s;
   float r[24];
} spin_t;

static int Ns=0,eoflg,nvt;
static double m0;
static dfl_gen_parms_t dgn;


static void init_once(void)
{
   int nb,isw;
   dfl_parms_t dfl;
   dfl_pro_parms_t dpr;

   dfl=dfl_parms();
   error_root(dfl.Ns==0,1,"init_once [dfl_modes.c]",
              "Parameters of the deflation subspace are not set");

   dpr=dfl_pro_parms();
   error_root(dpr.nkv==0,1,"init_once [dfl_modes.c]",
              "Deflation projection parameters are not set");

   dgn=dfl_gen_parms();
   error_root(dgn.ninv==0,1,"init_once [dfl_modes.c]",
              "Deflation subspace generation parameters are not set");

   (void)(blk_list(SAP_BLOCKS,&nb,&isw));

   if (nb==0)
      alloc_bgr(SAP_BLOCKS);

   (void)(blk_list(DFL_BLOCKS,&nb,&isw));

   if (nb==0)
   {
      alloc_bgr(DFL_BLOCKS);
      (void)(blk_list(DFL_BLOCKS,&nb,&isw));
   }

   Ns=dfl.Ns;
   nvt=(Ns*nb)/NTHREAD;
}


static int set_flds(void)
{
   int ifail;
   sw_parms_t sw;
   tm_parms_t tm;

   if (query_flags(U_MATCH_UD)!=1)
      assign_ud2u();

   if (query_grid_flags(SAP_BLOCKS,UBGR_MATCH_UD)!=1)
      assign_ud2ubgr(SAP_BLOCKS);

   sw=sw_parms();
   m0=sw.m0;

   if (dgn.m0!=m0)
      set_sw_parms(dgn.m0);
   sw_term(NO_PTS);

   if ((query_flags(SW_UP2DATE)!=1)||
       (query_flags(SW_E_INVERTED)==1)||(query_flags(SW_O_INVERTED)==1))
      assign_swd2sw();

   if ((query_grid_flags(SAP_BLOCKS,SW_UP2DATE)!=1)||
       (query_grid_flags(SAP_BLOCKS,SW_E_INVERTED)==1)||
       (query_grid_flags(SAP_BLOCKS,SW_O_INVERTED)!=1))
      ifail=assign_swd2swbgr(SAP_BLOCKS,ODD_PTS);
   else
      ifail=0;

   tm=tm_parms();
   eoflg=tm.eoflg;
   if (eoflg!=1)
      set_tm_parms(1);

   if (ifail)
      return -3;
   else
      return 0;
}


static void clean_up(void)
{
   if (m0!=dgn.m0)
      set_sw_parms(m0);
   if (eoflg!=1)
      set_tm_parms(eoflg);
}


static void random_fields(spinor **mds)
{
   int k,l,j;
   spin_t *s,*sm;

   for (l=0;l<Ns;l++)
   {
#pragma omp parallel private(k,j,s,sm)
      {
         k=omp_get_thread_num();

         s=(spin_t*)(mds[l])+k*VOLUME_TRD;
         sm=s+VOLUME_TRD;

         for (;s<sm;s++)
         {
            ranlxs((*s).r,24);

            for (j=0;j<24;j++)
               (*s).r[j]-=0.5f;
         }
      }

      bnd_s2zero(ALL_PTS,mds[l]);
   }
}

#ifdef DFL_MODES_DBG

static void print_res(spinor **mds)
{
   int l;
   double r;
   spinor **ws;

   ws=reserve_ws(1);

   for (l=0;l<Ns;l++)
   {
      Dw((float)(dgn.mu),mds[l],ws[0]);
      r=(double)(norm_square(VOLUME_TRD,3,ws[0])/
                 norm_square(VOLUME_TRD,3,mds[l]));
      message("l = %2d, |Dw*psi|/|psi| = %.1e\n",l,sqrt(r));
   }

   release_ws();
}


static void smooth_fields(int n,spinor **mds)
{
   int l,j;
   double r0,r1;
   spinor **ws;

   ws=reserve_ws(1);

   for (l=0;l<Ns;l++)
   {
      assign_s2s(VOLUME_TRD,2,mds[l],ws[0]);
      set_s2zero(VOLUME_TRD,2,mds[l]);
      r0=sqrt((double)(norm_square(VOLUME_TRD,3,ws[0])));

      for (j=0;j<n;j++)
         sap((float)(dgn.mu),1,dgn.nmr,mds[l],ws[0]);

      r1=sqrt((double)(norm_square(VOLUME_TRD,3,ws[0])));
      message("SAP smoothing of mode no %2d: "
              "residue %.1e -> %.1e, ratio = %.1e\n",l,r0,r1,r1/r0);
   }

   release_ws();
}


static void dfl_smooth_fields(spinor **mds,int *status)
{
   int l,j,ifail,stat[2];
   double r0,r1;
   complex **vs;
   complex_dble **wvd;
   spinor **ws;

   vs=vflds()+Ns;
   wvd=reserve_wvd(1);
   ws=reserve_ws(2);
   status[0]=0;
   status[1]=0;

   for (l=0;l<Ns;l++)
   {
      assign_v2vd(nvt,2,vs[l],wvd[0]);
      ltl_gcr(dgn.mu,wvd[0],wvd[0],&ifail,stat);
      dfl_vd2s(wvd[0],ws[1]);

      Dw((float)(dgn.mu),ws[1],ws[0]);
      diff_s2s(VOLUME_TRD,2,mds[l],ws[0]);
      set_s2zero(VOLUME_TRD,2,mds[l]);
      r0=sqrt((double)(norm_square(VOLUME_TRD,3,ws[0])));

      for (j=0;j<dgn.ncy;j++)
         sap((float)(dgn.mu),1,dgn.nmr,mds[l],ws[0]);

      add_s2s(VOLUME_TRD,2,ws[1],mds[l]);
      status[0]+=stat[0];
      status[1]+=stat[1];
      r1=sqrt((double)(norm_square(VOLUME_TRD,3,ws[0])));
      message("Deflated SAP smoothing of mode no %2d: "
              "ifail=%d, status = %d,%d, residue %.1e -> %.1e, ratio = %.1e\n",
              l,ifail,stat[0],stat[1],r0,r1,r1/r0);
   }

   release_ws();
   release_wvd();
}

#else

static void smooth_fields(int n,spinor **mds)
{
   int l,j;
   spinor **ws;

   ws=reserve_ws(1);

   for (l=0;l<Ns;l++)
   {
      assign_s2s(VOLUME_TRD,2,mds[l],ws[0]);
      set_s2zero(VOLUME_TRD,2,mds[l]);

      for (j=0;j<n;j++)
         sap((float)(dgn.mu),1,dgn.nmr,mds[l],ws[0]);
   }

   release_ws();
}


static void dfl_smooth_fields(spinor **mds,int *status)
{
   int l,j,ifail,stat[2];
   complex **vs;
   complex_dble **wvd;
   spinor **ws;

   vs=vflds()+Ns;
   wvd=reserve_wvd(1);
   ws=reserve_ws(2);
   status[0]=0;
   status[1]=0;

   for (l=0;l<Ns;l++)
   {
      assign_v2vd(nvt,2,vs[l],wvd[0]);
      ltl_gcr(dgn.mu,wvd[0],wvd[0],&ifail,stat);
      dfl_vd2s(wvd[0],ws[1]);

      Dw((float)(dgn.mu),ws[1],ws[0]);
      diff_s2s(VOLUME_TRD,2,mds[l],ws[0]);
      set_s2zero(VOLUME_TRD,2,mds[l]);

      for (j=0;j<dgn.ncy;j++)
         sap((float)(dgn.mu),1,dgn.nmr,mds[l],ws[0]);

      add_s2s(VOLUME_TRD,2,ws[1],mds[l]);
      status[0]+=stat[0];
      status[1]+=stat[1];
   }

   release_ws();
   release_wvd();
}

#endif

void dfl_modes(int *ifail,int *status)
{
   int n,stat[2];
   spinor **mds;

   if (Ns==0)
      init_once();

   ifail[0]=set_flds();
   status[0]=0;
   status[1]=0;
   mds=reserve_ws(Ns);
   random_fields(mds);

#ifdef DFL_MODES_DBG
   message("[dfl_modes]: Progress report\n");
   message("[dfl_modes]: Ns = %d, ninv = %d, nmr = %d, ncy = %d\n",
           Ns,dgn.ninv,dgn.nmr,dgn.ncy);
   if (ifail[0]!=0)
      message("[dfl_modes]: Inversion of the SW term failed\n");
#endif

   if (ifail[0]!=0)
      dfl_subspace(mds);
   else
   {
      for (n=0;n<3;n++)
      {
         smooth_fields(n+1,mds);
#ifdef DFL_MODES_DBG
         print_res(mds);
#endif
      }

      dfl_subspace(mds);

      for (;(n<dgn.ninv)&&(ifail[0]==0);n++)
      {
         if (set_Awhat(dgn.mu))
         {
            ifail[0]=-2;
#ifdef DFL_MODES_DBG
            message("[dfl_modes]: Inversion of Awblk failed\n");
#endif
         }
         else
         {
            dfl_smooth_fields(mds,stat);
            dfl_renormalize_modes(mds);
            dfl_subspace(mds);
            status[0]+=stat[0];
            status[1]+=stat[1];
#ifdef DFL_MODES_DBG
            print_res(mds);
#endif
         }
      }

      if (ifail[0]==0)
         n=Ns*(n-3);
      else
         n=Ns*(n-4);

      if (n!=0)
      {
         status[0]=(status[0]+n/2)/n;
         status[1]=(status[1]+n/2)/n;
      }
   }

   release_ws();
   clean_up();

#ifdef DFL_MODES_DBG
   message("[dfl_modes]: ifail=%d, status = %d,%d\n",
           ifail[0],status[0],status[1]);
   message("[dfl_modes]: All done\n\n");
#endif
}


void dfl_update(int nsm,int *ifail,int *status)
{
   int n,stat[2],iprms[1];
   spinor **mds;

   error_root(Ns==0,1,"dfl_update [dfl_modes.c]",
              "No previous call of dfl_modes()");

   if (NPROC>1)
   {
      iprms[0]=nsm;
      MPI_Bcast(iprms,1,MPI_INT,0,MPI_COMM_WORLD);
      error(iprms[0]!=nsm,1,"dfl_update [dfl_modes.c]",
            "Parameters are not global");
   }

   ifail[0]=set_flds();
   status[0]=0;
   status[1]=0;

#ifdef DFL_MODES_DBG
   message("[dfl_update]: Progress report\n");
   message("[dfl_update]: Ns = %d, nsm = %d, ninv = %d, nmr = %d, ncy = %d\n",
           Ns,nsm,dgn.ninv,dgn.nmr,dgn.ncy);
   if (ifail[0]!=0)
      message("[dfl_update]: Inversion of the SW term failed\n");
#endif

   if (ifail[0]==0)
   {
      mds=reserve_ws(Ns);
      dfl_restore_modes(mds);

      for (n=0;(n<nsm)&&(ifail[0]==0);n++)
      {
         if (set_Awhat(dgn.mu))
         {
            ifail[0]=-2;
#ifdef DFL_MODES_DBG
            message("[dfl_update]: Inversion of Awblk failed\n");
#endif
         }
         else
         {
            dfl_smooth_fields(mds,stat);
            dfl_renormalize_modes(mds);
            dfl_subspace(mds);
            status[0]+=stat[0];
            status[1]+=stat[1];
#ifdef DFL_MODES_DBG
            print_res(mds);
#endif
         }
      }

      if (ifail[0]==0)
         n=Ns*n;
      else
         n=Ns*(n-1);

      if (n!=0)
      {
         status[0]=(status[0]+n/2)/n;
         status[1]=(status[1]+n/2)/n;
      }

      release_ws();
   }

   clean_up();

#ifdef DFL_MODES_DBG
   message("[dfl_update]: ifail=%d, status = %d,%d\n",
           ifail[0],status[0],status[1]);
   message("[dfl_update]: All done\n\n");
#endif
}


void dfl_modes2(int *ifail,int *status)
{
   dfl_modes(ifail,status);

   if (ifail[0]==-2)
   {
#ifdef DFL_MODES_DBG
      message("[dfl_modes2]: Generation of the deflation subspace failed\n");
      message("[dfl_modes2]: Start second attempt\n");
#endif
      dfl_modes(ifail+1,status+2);
   }
   else
   {
      ifail[1]=0;
      status[2]=0;
      status[3]=0;
   }
}


void dfl_update2(int nsm,int *ifail,int *status)
{
   dfl_update(nsm,ifail,status);

   if (ifail[0]==-2)
   {
#ifdef DFL_MODES_DBG
      message("[dfl_update2]: Update of the deflation subspace failed\n");
      message("[dfl_update2]: Attempt to regenerate the subspace\n");
#endif
      dfl_modes(ifail+1,status+2);
   }
   else
   {
      ifail[1]=0;
      status[2]=0;
      status[3]=0;
   }
}
