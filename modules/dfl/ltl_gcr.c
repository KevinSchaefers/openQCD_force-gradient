
/*******************************************************************************
*
* File ltl_gcr.c
*
* Copyright (C) 2011-2013, 2018, 2022 Martin Luescher
*
* This software is distributed under the terms of the GNU General Public
* License (GPL)
*
* FGCR solver for the double-precision little Dirac equation.
*
*   double ltl_gcr(double mu,complex_dble *eta,complex_dble *psi,
*                  int *ifail,int *status)
*     Obtains an approximate solution psi of the little Dirac equation
*     Aw*psi=eta for given source eta and twisted mass mu.
*
* The program is based on the flexible GCR algorithm for the even-odd
* preconditioned little Dirac equation and a single-pass GCR algorithm as
* preconditioner for the latter (see fgcr4vd.c and gcr4v.c in the module
* directory linsolv). Global-mode deflation is applied in addition at
* the level of the eo-preconditioned operator (see little/ltl_modes.c).
*
* The solver has a number of parameters that are retrieved from the parameter
* data base:
*
*  nkv            Maximal number of Krylov vectors to be used by the
*                 fgcr4vd() solver for the little Dirac equation before
*                 a restart.
*
*  nmx            Maximal total number of Krylov vectors generated by
*                 the fgcr4vd() solver for the little Dirac equation.
*
*  res            Required relative residue of the calculated solution
*                 of the eo-preconditioned little Dirac equation.
*
*  nmx_gcr        Maximal number of Krylov vectors to be used by the
*                 gcr4v() preconditioner of the little Dirac equation.
*
*  res_gcr        Desired relative residue to be reached by the gcr4v()
*                 preconditioner.
*
* These must be set by calling set_dfl_pro_parms() [flags/dfl_parms.c] before
* the solver is launched.
*
* The parameters of the SW term and of the deflation subspace must have been
* set by set_lat_parms(), set_bc_parms(), set_sw_parms() and set_dfl_parms()
* and it is taken for granted that the deflation subspace has been initialized
* by calling dfl_subspace(). The eo-preconditioned little Dirac operator is
* updated if it is not up-to-date.
*
* The parameters passed through the argument list are:
*
*   mu      Value of the twisted mass in the Dirac equation. If the
*           twisted-mass flag [flags/lat_parms.c] is set, the twisted
*           mass term is set to zero on the odd sites of the lattice.
*
*   eta     Source field (unchanged on exit unless psi=eta).
*
*   psi     Calculated approximate solution of the little Dirac equation.
*
*   ifail   On exit ifail=0 if the program was able to solve the little
*           Dirac equation to the desired accuracy, ifail=-1 if the solver
*           did not converge and ifail=-2 if the inversion of the diagonal
*           elements of the little Dirac operator was not safe.
*
*   status  On exit status[0] and status[1] report the total number of
*           Krylov vectors generated by the fgcr4vd() solver and the
*           gcr4v() preconditioner.
*
* If ifail[0]>=-1, the program returns the norm of the residue of the
* calculated solution of the eo-preconditioned little Dirac equation. If
* ifail[0]=-2, the program returns the norm of the source eta and sets
* psi to zero if psi!=eta.
*
* The fields eta and psi are assumed to have at least Ns*nb components,
* where Ns is the number of deflation modes and nb the number of blocks
* in the DFL_BLOCKS block grid contained in the local lattice.
*
* The required workspaces are
*
*  complex             2*nmx_gcr+3
*  complex_dble        2*nkv+3
*
* (see utils/wspace.c).
*
* The program ltl_gcr() is assumed to be called by the OpenMP master thread
* on all MPI processes simultaneously.
*
*******************************************************************************/

#define LTL_GCR_C

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <omp.h>
#include "mpi.h"
#include "utils.h"
#include "flags.h"
#include "vflds.h"
#include "linalg.h"
#include "linsolv.h"
#include "little.h"
#include "dfl.h"
#include "global.h"

static int nvh,nvt;
static int nmx_gcr,*stat_gcr;
static double tol,res_gcr;
static complex **wvs;


static void Dop(complex *v,complex *w)
{
   Awhat(v,w);
   dfl_Lv(w);
}


static void Mop(complex_dble *vd,complex_dble *wd,complex_dble *zd)
{
   int status;
   float res;
   double rn;

   assign_vd2v(nvt,2,vd,wvs[0]);
   rn=sqrt(vnorm_square(nvt,3,wvs[0]));

   if ((rn*res_gcr)<tol)
      res=(float)(tol/rn);
   else
      res=(float)(res_gcr);

   (void)(gcr4v(nvt,Dop,wvs+2,nmx_gcr,res,wvs[0],wvs[1],&status));

   if (status<0)
      (*stat_gcr)+=nmx_gcr;
   else
      (*stat_gcr)+=status;

   assign_v2vd(nvt,2,wvs[1],wd);
   Awhat_dble(wd,zd);
   dfl_RLvd(wd,zd);
}


static void Dop_dble(complex_dble *vd,complex_dble *wd)
{
   Awhat_dble(vd,wd);
   dfl_Lvd(wd);
}


double ltl_gcr(double mu,complex_dble *eta,complex_dble *psi,
               int *ifail,int *status)
{
   double rho,rho0,rho1,res,fact;
   qflt rqsm;
   complex_dble **wvd;
   Aw_dble_t Aw;
   dfl_pro_parms_t dpr;

   dpr=dfl_pro_parms();

   Aw=Awophat_dble();
   nvh=(Aw.Ns*Aw.nb)/2;
   nvt=nvh/NTHREAD;

   ifail[0]=0;
   status[0]=0;
   status[1]=0;

   if (set_Awhat(mu))
   {
      ifail[0]=-2;
      if (psi!=eta)
         set_vd2zero(2*nvt,2,psi);
      rqsm=vnorm_square_dble(2*nvt,3,eta);
      rho=sqrt(rqsm.q[0]);
   }
   else
   {
      wvs=reserve_wv(2*dpr.nmx_gcr+3);
      wvd=reserve_wvd(2*dpr.nkv+3);

      assign_vd2vd(nvt,2,eta,wvd[1]);
      Awooinv_dble(eta,wvd[1]);
      Aweo_dble(wvd[1],wvd[1]);
      Aweeinv_dble(wvd[1],wvd[0]);

      rqsm=vnorm_square_dble(nvt,3,wvd[0]);
      rho0=sqrt(rqsm.q[0]);
      dfl_LRvd(wvd[0],wvd[0]+nvh);
      rqsm=vnorm_square_dble(nvt,3,wvd[0]);
      rho1=sqrt(rqsm.q[0]);

      if (rho1!=0.0)
      {
         nmx_gcr=dpr.nmx_gcr;
         stat_gcr=status+1;

         fact=sqrt((double)(NPROC*nvh))/rho1;
         vscale_dble(nvt,2,fact,wvd[0]);

         res=(rho0/rho1)*dpr.res;
         res_gcr=(rho0/rho1)*dpr.res_gcr;
         tol=fact*rho1*res;

         rho=fgcr4vd(nvt,Dop_dble,Mop,wvd+2,dpr.nkv,dpr.nmx,(rho0/rho1)*dpr.res,
                     wvd[0],wvd[1],status);

         fact=1.0/fact;
         vscale_dble(nvt,2,fact,wvd[1]);
         add_vd2vd(nvt,2,wvd[0]+nvh,wvd[1]);
         rho*=fact;

         if (status[0]<0)
         {
            ifail[0]=-1;
            status[0]=dpr.nmx;
         }
      }
      else
      {
         rho=0.0;
         assign_vd2vd(nvt,2,wvd[0]+nvh,wvd[1]);
      }

      Awoe_dble(wvd[1],wvd[1]);
      assign_vd2vd(nvt,2,wvd[1],psi);
      diff_vd2vd(nvt,2,eta+nvh,wvd[1]+nvh);
      Awooinv_dble(wvd[1],psi);

      release_wvd();
      release_wv();
   }

   return rho;
}
