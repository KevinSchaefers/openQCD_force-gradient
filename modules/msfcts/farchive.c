
/*******************************************************************************
*
* File farchive.c
*
* Copyright (C) 2017, 2018, 2022 Martin Luescher
*
* This software is distributed under the terms of the GNU General Public
* License (GPL)
*
* I/O functions for real-valued observable fields.
*
*   void write_msfld(char *out,int n,double **f)
*     Writes the lattice sizes, the process grid sizes, the coordinates of
*     the calling process, the (local) square norms of the fields f[0],..,
*     f[n-1] and the local parts of the fields to the file "out".
*
*   void read_msfld(char *in,int n,double **f)
*     Reads the fields f[0],..,f[n-1] from the file "in" assuming they were
*     written to the file by the program write_msfld().
*
*   void export_msfld(char *out,int n,double **f)
*     Writes the lattice sizes, the square norms of the fields f[0],..f[n-1]
*     and the fields to the file "out" from process 0. The field variables
*     are written in the "universal" order specified in the notes.
*
*   void import_msfld(char *in,int n,double **f)
*     Reads the fields f[0],..,f[n-1] from the file "in" on process 0,
*     assuming they were written to the file by the program export_msfld().
*
*   void blk_export_msfld(int *bs,char *out,int n,double **f)
*     Divides the lattice into logical blocks with sizes bs[0],..,bs[3].
*     The MPI processes, where the local lattice contains the base point
*     of a block, then write the lattice sizes, the block sizes, the base
*     point coordinates, the square norms of the fields f[0],..,f[n-1] and
*     the parts of the fields residing on the block to the file "out". The
*     fields are written in the "universal" order specified in the notes.
*
*   void blk_import_msfld(char *in,int n,double **f)
*     Performs the same operation as import_msfld(), but expects the file
*     "in" to contain fields written by the program blk_export_msfld().
*     The program reads the block size from the configuration file on the
*     MPI process with coordinates (0,0,0,0) in the process grid.
*
* All these programs operate on real-valued double-precision fields of local
* size VOLUME. In memory the field variables are ordered according to the
* point index defined by the geometry routines. The export functions store
* the field variables in lexicographic order.
*
* In the case of block-exported storage with block sizes B0xB1xB2xB3, the
* field variables at the points x are thus ordered according to the index
*
*   ix=x3+x2*B3+x1*B2*B3+x0*B1*B2*B3
*
* where (x0,x1,x2,x3) are the coordinates of x relative to the base point
* of the block. The export_msfld() function does the same with B0,..,B3 set
* to the global lattice sizes. The n fields stored are written point by
* point, i.e first come the values of the fields f[0],..,f[n-1] at the first
* point, then the n values at the second point and so on.
*
* The block sizes bs passed to the program blk_export_msfld() must divide the
* (global) lattice sizes and must be multiples of the local lattice sizes.
*
* The programs blk_size(), blk_index() and blk_root_process() can be used to
* read the header data on the files generated by blk_export_msfld() as in the
* case of the block-exported gauge-field configurations [archive/archive.c].
*
* All programs in this module are assumed to be called by the OpenMP master
* thread on all MPI processes simultaneously.
*
*******************************************************************************/

#define FARCHIVE_C

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <omp.h>
#include "mpi.h"
#include "utils.h"
#include "lattice.h"
#include "archive.h"
#include "msfcts.h"
#include "global.h"

#define N0 (NPROC0*L0)
#define N1 (NPROC1*L1)
#define N2 (NPROC2*L2)
#define N3 (NPROC3*L3)

static int my_rank,endian,ns=0;
static int tag0,tag1;
static double *fbuf,*gbuf,*snrm;


static void alloc_fbuf(int n)
{
   int i;

   if (ns==0)
   {
      tag0=mpi_permanent_tag();
      tag1=mpi_permanent_tag();
      endian=endianness();
      error_root(ipt==NULL,1,"alloc_fbuf [farchive.c]",
                 "Geometry arrays are not set");
   }
   else
      free(fbuf);

   fbuf=malloc((n*L3+n*N3+n)*sizeof(double));
   gbuf=fbuf+n*L3;
   snrm=gbuf+n*N3;
   error_loc(fbuf==NULL,1,"alloc_fbuf [farchive.c]",
             "Unable to allocate auxiliary array");

   for (i=0;i<(n*L3+n*N3+n);i++)
      fbuf[i]=0.0;

   ns=n;
}


static double square_norm(int icom,double *f)
{
   int k;
   double sn,*fr,*fm,*qsm[1];
   qflt rqsm;

   rqsm.q[0]=0.0;
   rqsm.q[1]=0.0;

#pragma omp parallel private(k,sn,fr,fm) reduction(sum_qflt : rqsm)
   {
      k=omp_get_thread_num();

      fr=f+k*VOLUME_TRD;
      fm=fr+VOLUME_TRD;

      for (;fr<fm;fr+=8)
      {
         sn=fr[0]*fr[0]+fr[1]*fr[1]+fr[2]*fr[2]+fr[3]*fr[3]+
            fr[4]*fr[4]+fr[5]*fr[5]+fr[6]*fr[6]+fr[7]*fr[7];
         acc_qflt(sn,rqsm.q);
      }
   }

   if ((NPROC>1)&&(icom&0x1))
   {
      qsm[0]=rqsm.q;
      global_qsum(1,qsm,qsm);
   }

   return rqsm.q[0];
}


void write_msfld(char *out,int n,double **f)
{
   int iw,ldat[17];
   int nios,m,i,j,iprms[1];
   double sn;
   FILE *fout;

   MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);

   error_root(n<1,1,"write_msfld [farchive.c]",
              "Parameter n is out of range");

   if (NPROC>1)
   {
      iprms[0]=n;
      MPI_Bcast(iprms,1,MPI_INT,0,MPI_COMM_WORLD);

      error(iprms[0]!=n,1,"write_msfld [farchive.c]",
            "Parameters are not global");
   }

   if (n>ns)
      alloc_fbuf(n);

   ldat[0]=NPROC0;
   ldat[1]=NPROC1;
   ldat[2]=NPROC2;
   ldat[3]=NPROC3;

   ldat[4]=L0;
   ldat[5]=L1;
   ldat[6]=L2;
   ldat[7]=L3;

   ldat[8]=NPROC0_BLK;
   ldat[9]=NPROC1_BLK;
   ldat[10]=NPROC2_BLK;
   ldat[11]=NPROC3_BLK;

   ldat[12]=cpr[0];
   ldat[13]=cpr[1];
   ldat[14]=cpr[2];
   ldat[15]=cpr[3];

   ldat[16]=n;

   nios=nio_streams();
   error_root((nios<1)||(NPROC%nios),1,"write_cnfg [farchive.c]",
              "Improper number of parallel I/O streams");
   m=NPROC/nios;

   for (i=0;i<m;i++)
   {
      if (i==(my_rank%m))
      {
         fout=fopen(out,"wb");
         error_loc(fout==NULL,1,"write_cnfg [farchive.c]",
                   "Unable to open output file");

         iw=fwrite(ldat,sizeof(int),17,fout);

         for (j=0;j<n;j++)
         {
            sn=square_norm(0,f[j]);
            iw+=fwrite(&sn,sizeof(double),1,fout);
            iw+=fwrite(f[j],sizeof(double),VOLUME,fout);
         }

         error_loc(iw!=(17+n*(1+VOLUME)),1,"write_cnfg [farchive.c]",
                   "Incorrect write count");
         fclose(fout);
      }

      MPI_Barrier(MPI_COMM_WORLD);
   }
}


void read_msfld(char *in,int n,double **f)
{
   int ir,ie,ldat[17];
   int nios,m,i,j,iprms[1];
   double sn0,sn1,eps;
   FILE *fin;

   MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);

   error_root(n<1,1,"read_msfld [farchive.c]",
              "Parameter n is out of range");

   if (NPROC>1)
   {
      iprms[0]=n;
      MPI_Bcast(iprms,1,MPI_INT,0,MPI_COMM_WORLD);

      error(iprms[0]!=n,1,"read_msfld [farchive.c]",
            "Parameters are not global");
   }

   if (n>ns)
      alloc_fbuf(n);

   nios=nio_streams();
   error_root((nios<1)||(NPROC%nios),1,"read_cnfg [farchive.c]",
              "Improper number of parallel I/O streams");
   m=NPROC/nios;
   eps=64.0*DBL_EPSILON;

   for (i=0;i<m;i++)
   {
      if (i==(my_rank%m))
      {
         fin=fopen(in,"rb");
         error_loc(fin==NULL,1,"read_cnfg [farchive.c]",
                   "Unable to open input file");

         ir=fread(ldat,sizeof(int),17,fin);

         ie=0;
         ie|=((ldat[0]!=NPROC0)||(ldat[1]!=NPROC1)||
              (ldat[2]!=NPROC2)||(ldat[3]!=NPROC3));
         ie|=((ldat[4]!=L0)||(ldat[5]!=L1)||
              (ldat[6]!=L2)||(ldat[7]!=L3));
         ie|=((ldat[8]!=NPROC0_BLK)||(ldat[9]!=NPROC1_BLK)||
              (ldat[10]!=NPROC2_BLK)||(ldat[11]!=NPROC3_BLK));
         ie|=((ldat[12]!=cpr[0])||(ldat[13]!=cpr[1])||
              (ldat[14]!=cpr[2])||(ldat[15]!=cpr[3]));
         ie|=(ldat[16]!=n);
         error_loc(ie!=0,1,"read_cnfg [farchive.c]",
                   "Unexpected process grid, lattice data or number of fields");

         for (j=0;j<n;j++)
         {
            ir+=fread(&sn0,sizeof(double),1,fin);
            ir+=fread(f[j],sizeof(double),VOLUME,fin);
            sn1=square_norm(0,f[j]);
            ie|=(fabs(sn1-sn0)>(eps*(sn0+sn1)));
         }

         error_loc(ir!=(17+n*(1+VOLUME)),1,"read_cnfg [farchive.c]",
                   "Incorrect read count");
         error_loc(ie!=0,1,"read_cnfg [farchive.c]",
                   "Incorrect field square norms");
         fclose(fin);
      }

      MPI_Barrier(MPI_COMM_WORLD);
   }
}


static void get_msfld(int iy,int n,double **f)
{
   int y3,ix,i;
   double *fb;

   fb=fbuf;
   iy*=L3;

   for (y3=0;y3<L3;y3++)
   {
      ix=ipt[iy+y3];

      for (i=0;i<n;i++)
      {
         fb[0]=f[i][ix];
         fb+=1;
      }
   }
}


static void set_msfld(int iy,int n,double **f)
{
   int y3,ix,i;
   double *fb;

   fb=fbuf;
   iy*=L3;

   for (y3=0;y3<L3;y3++)
   {
      ix=ipt[iy+y3];

      for (i=0;i<n;i++)
      {
         f[i][ix]=fb[0];
         fb+=1;
      }
   }
}


static void get_line(int ip0,int n3,int x0,int x1,int x2,int x3,
                     int n,double **f)
{
   int y0,y1,y2,y3,iy,i;
   int dmy,ip1,np[4];
   MPI_Status stat;

   y0=x0%L0;
   y1=x1%L1;
   y2=x2%L2;
   iy=y2+y1*L2+y0*L1*L2;

   dmy=1;
   np[0]=x0/L0;
   np[1]=x1/L1;
   np[2]=x2/L2;

   for (y3=0;y3<n3;y3+=L3)
   {
      np[3]=(x3+y3)/L3;
      ip1=ipr_global(np);

      if (my_rank==ip1)
         get_msfld(iy,n,f);

      if (ip1!=ip0)
      {
         if (my_rank==ip0)
         {
            MPI_Send(&dmy,1,MPI_INT,ip1,tag0,MPI_COMM_WORLD);
            MPI_Recv(gbuf+n*y3,n*L3,MPI_DOUBLE,ip1,tag1,MPI_COMM_WORLD,
                     &stat);
         }
         else if (my_rank==ip1)
         {
            MPI_Recv(&dmy,1,MPI_INT,ip0,tag0,MPI_COMM_WORLD,&stat);
            MPI_Send(fbuf,n*L3,MPI_DOUBLE,ip0,tag1,MPI_COMM_WORLD);
         }
      }
      else if (my_rank==ip0)
      {
         for (i=0;i<(n*L3);i++)
            gbuf[n*y3+i]=fbuf[i];
      }
   }
}


static void set_line(int ip0,int n3,int x0,int x1,int x2,int x3,
                     int n,double **f)
{
   int y0,y1,y2,y3,iy,i;
   int dmy,ip1,np[4];
   MPI_Status stat;

   y0=x0%L0;
   y1=x1%L1;
   y2=x2%L2;
   iy=y2+y1*L2+y0*L1*L2;

   dmy=1;
   np[0]=x0/L0;
   np[1]=x1/L1;
   np[2]=x2/L2;

   for (y3=0;y3<n3;y3+=L3)
   {
      np[3]=(x3+y3)/L3;
      ip1=ipr_global(np);

      if (ip1!=ip0)
      {
         if (my_rank==ip0)
         {
            MPI_Send(gbuf+n*y3,n*L3,MPI_DOUBLE,ip1,tag1,MPI_COMM_WORLD);
            MPI_Recv(&dmy,1,MPI_INT,ip1,tag0,MPI_COMM_WORLD,&stat);
         }
         else if (my_rank==ip1)
         {
            MPI_Recv(fbuf,n*L3,MPI_DOUBLE,ip0,tag1,MPI_COMM_WORLD,
                     &stat);
            MPI_Send(&dmy,1,MPI_INT,ip0,tag0,MPI_COMM_WORLD);
         }
      }
      else if (my_rank==ip1)
      {
         for (i=0;i<(n*L3);i++)
            fbuf[i]=gbuf[n*y3+i];
      }

      if (my_rank==ip1)
         set_msfld(iy,n,f);
   }
}


void export_msfld(char *out,int n,double **f)
{
   int x0,x1,x2,ix,iy,i;
   int iw,iwa,iprms[1];
   stdint_t lsize[5];
   FILE *fout=NULL;

   MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);

   error_root(n<1,1,"export_msfld [farchive.c]",
              "Parameter n is out of range");

   if (NPROC>1)
   {
      iprms[0]=n;
      MPI_Bcast(iprms,1,MPI_INT,0,MPI_COMM_WORLD);

      error(iprms[0]!=n,1,"export_msfld [farchive.c]",
            "Parameters are not global");
   }

   if (n>ns)
      alloc_fbuf(n);

   for (i=0;i<n;i++)
      snrm[i]=square_norm(1,f[i]);

   if (my_rank==0)
   {
      fout=fopen(out,"wb");
      error_root(fout==NULL,1,"export_msfld [farchive.c]",
                 "Unable to open output file");

      lsize[0]=(stdint_t)(N0);
      lsize[1]=(stdint_t)(N1);
      lsize[2]=(stdint_t)(N2);
      lsize[3]=(stdint_t)(N3);
      lsize[4]=(stdint_t)(n);

      if (endian==BIG_ENDIAN)
      {
         bswap_int(5,lsize);
         bswap_double(n,snrm);
      }

      iw=fwrite(lsize,sizeof(stdint_t),5,fout);
      iw+=fwrite(snrm,sizeof(double),n,fout);

      error_root(iw!=(5+n),1,"export_msfld [farchive.c]",
                 "Incorrect write count");
   }

   iwa=0;

   for (ix=0;ix<(N0*N1*N2);ix++)
   {
      iy=ix;
      x2=iy%N2;
      iy/=N2;
      x1=iy%N1;
      iy/=N1;
      x0=iy;

      get_line(0,N3,x0,x1,x2,0,n,f);

      if (my_rank==0)
      {
         if (endian==BIG_ENDIAN)
            bswap_double(n*N3,gbuf);

         iw=fwrite(gbuf,sizeof(double),n*N3,fout);
         iwa|=(iw!=(n*N3));
      }
   }

   if (my_rank==0)
   {
      error_root(iwa!=0,1,"export_msfld [farchive.c]",
                 "Incorrect write count");
      fclose(fout);
   }
}


void import_msfld(char *in,int n,double **f)
{
   int x0,x1,x2,ix,iy,i;
   int ir,ira,ie,iprms[1];
   stdint_t lsize[5];
   double sn0,sn1,eps;
   FILE *fin=NULL;

   MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);

   error_root(n<1,1,"import_msfld [farchive.c]",
              "Parameter n is out of range");

   if (NPROC>1)
   {
      iprms[0]=n;
      MPI_Bcast(iprms,1,MPI_INT,0,MPI_COMM_WORLD);

      error(iprms[0]!=n,1,"import_msfld [farchive.c]",
            "Parameters are not global");
   }

   if (n>ns)
      alloc_fbuf(n);

   if (my_rank==0)
   {
      fin=fopen(in,"rb");
      error_root(fin==NULL,1,"import_msfld [farchive.c]",
                 "Unable to open input file");

      ir=fread(lsize,sizeof(stdint_t),5,fin);
      error_root(ir!=5,1,"import_msfld [farchive.c]",
                 "Incorrect read count");

      if (endian==BIG_ENDIAN)
         bswap_int(5,lsize);

      ie=0;
      ie|=((int)(lsize[0])!=N0);
      ie|=((int)(lsize[1])!=N1);
      ie|=((int)(lsize[2])!=N2);
      ie|=((int)(lsize[3])!=N3);
      ie|=((int)(lsize[4])!=n);

      error_root(ie!=0,1,"import_msfld [farchive.c]",
                 "Unexpected lattice sizes or number of fields");

      ir=fread(snrm,sizeof(double),n,fin);
      error_root(ir!=n,1,"import_msfld [farchive.c]",
                 "Incorrect read count");

      if (endian==BIG_ENDIAN)
         bswap_double(n,snrm);
   }

   ira=0;

   for (ix=0;ix<(N0*N1*N2);ix++)
   {
      iy=ix;
      x2=iy%N2;
      iy/=N2;
      x1=iy%N1;
      iy/=N1;
      x0=iy;

      if (my_rank==0)
      {
         ir=fread(gbuf,sizeof(double),n*N3,fin);
         ira|=(ir!=(n*N3));

         if (endian==BIG_ENDIAN)
            bswap_double(n*N3,gbuf);
      }

      set_line(0,N3,x0,x1,x2,0,n,f);
   }

   if (my_rank==0)
   {
      error_root(ira!=0,1,"import_msfld [farchive.c]",
                 "Incorrect read count");
      fclose(fin);
   }

   eps=64.0*DBL_EPSILON;
   ie=0;

   for (i=0;i<n;i++)
   {
      sn1=square_norm(1,f[i]);

      if (my_rank==0)
      {
         sn0=snrm[i];
         ie|=(fabs(sn1-sn0)>(eps*(sn0+sn1)));
      }
   }

   error_root(ie!=0,1,"import_msfld [farchive.c]",
              "Incorrect field square norms");
}


void blk_export_msfld(int *bs,char *out,int n,double **f)
{
   int nl[4],bo[4];
   int ip0,iw,iwa;
   int x0,x1,x2,ix,iy;
   int nios,m,i,nb,ib,iprms[5];
   stdint_t lsize[13];
   FILE *fout=NULL;

   MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);

   error_root(n<1,1,"blk_export_msfld [farchive.c]",
              "Parameter n is out of range");

   if (NPROC>1)
   {
      iprms[0]=bs[0];
      iprms[1]=bs[1];
      iprms[2]=bs[2];
      iprms[3]=bs[3];
      iprms[4]=n;
      MPI_Bcast(iprms,5,MPI_INT,0,MPI_COMM_WORLD);

      error((iprms[0]!=bs[0])||(iprms[1]!=bs[1])||(iprms[2]!=bs[2])||
            (iprms[3]!=bs[3])||(iprms[4]!=n),1,"blk_export_msfld [farchive.c]",
            "Parameters are not global");
   }

   if (n>ns)
      alloc_fbuf(n);

   for (i=0;i<n;i++)
      snrm[i]=square_norm(1,f[i]);

   nl[0]=N0;
   nl[1]=N1;
   nl[2]=N2;
   nl[3]=N3;
   ip0=blk_root_process(nl,bs,bo,&nb,&ib);
   nios=nio_streams();
   error_root((nios<1)||((nb%nios)!=0),1,"blk_export_msfld [farchive.c]",
              "Improper number of parallel I/O streams");
   m=nb/nios;

   for (i=0;i<m;i++)
   {
      if (i==(ib%m))
      {
         if (my_rank==ip0)
         {
            fout=fopen(out,"wb");
            error_loc(fout==NULL,1,"blk_export_msfld [farchive.c]",
                      "Unable to open output file");

            lsize[0]=(stdint_t)(N0);
            lsize[1]=(stdint_t)(N1);
            lsize[2]=(stdint_t)(N2);
            lsize[3]=(stdint_t)(N3);
            lsize[4]=(stdint_t)(bs[0]);
            lsize[5]=(stdint_t)(bs[1]);
            lsize[6]=(stdint_t)(bs[2]);
            lsize[7]=(stdint_t)(bs[3]);
            lsize[8]=(stdint_t)(bo[0]);
            lsize[9]=(stdint_t)(bo[1]);
            lsize[10]=(stdint_t)(bo[2]);
            lsize[11]=(stdint_t)(bo[3]);
            lsize[12]=(stdint_t)(n);

            if (endian==BIG_ENDIAN)
            {
               bswap_int(13,lsize);
               bswap_double(n,snrm);
            }

            iw=fwrite(lsize,sizeof(stdint_t),13,fout);
            iw+=fwrite(snrm,sizeof(double),n,fout);

            error_loc(iw!=(13+n),1,"blk_export_msfld [farchive.c]",
                      "Incorrect write count");
         }

         iwa=0;

         for (ix=0;ix<(bs[0]*bs[1]*bs[2]);ix++)
         {
            iy=ix;
            x2=iy%bs[2];
            iy/=bs[2];
            x1=iy%bs[1];
            iy/=bs[1];
            x0=iy;

            x0+=bo[0];
            x1+=bo[1];
            x2+=bo[2];

            get_line(ip0,bs[3],x0,x1,x2,bo[3],n,f);

            if (my_rank==ip0)
            {
               if (endian==BIG_ENDIAN)
                  bswap_double(n*bs[3],gbuf);
               iw=fwrite(gbuf,sizeof(double),n*bs[3],fout);
               iwa|=(iw!=(n*bs[3]));
            }
         }

         if (my_rank==ip0)
         {
            error_loc(iwa!=0,1,"blk_export_msfld [farchive.c]",
                      "Incorrect write count");
            fclose(fout);
         }
      }

      MPI_Barrier(MPI_COMM_WORLD);
   }
}


void blk_import_msfld(char *in,int n,double **f)
{
   int nl[4],bs[4],bo[4];
   int ip0,ir,ira,ie;
   int x0,x1,x2,ix,iy;
   int nios,m,i,nb,ib,iprms[1];
   stdint_t lsize[13];
   double sn0,sn1,eps;
   FILE *fin=NULL;

   MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);

   error_root(n<1,1,"blk_import_msfld [farchive.c]",
              "Parameter n is out of range");

   if (NPROC>1)
   {
      iprms[0]=n;
      MPI_Bcast(iprms,1,MPI_INT,0,MPI_COMM_WORLD);

      error(iprms[0]!=n,1,"blk_import_msfld [farchive.c]",
            "Parameters are not global");
   }

   if (n>ns)
      alloc_fbuf(n);

   blk_sizes(in,nl,bs);
   error_root((nl[0]!=N0)||(nl[1]!=N1)||(nl[2]!=N2)||(nl[3]!=N3),1,
              "blk_import_msfld [farchive.c]","Unexpected lattice sizes");

   ip0=blk_root_process(nl,bs,bo,&nb,&ib);
   nios=nio_streams();
   error_root((nios<1)||((nb%nios)!=0),1,"blk_import_msfld [farchive.c]",
              "Improper number of parallel I/O streams");
   m=nb/nios;

   for (i=0;i<m;i++)
   {
      if (i==(ib%m))
      {
         if (my_rank==ip0)
         {
            fin=fopen(in,"rb");
            error_loc(fin==NULL,1,"blk_import_msfld [farchive.c]",
                      "Unable to open input file");

            ir=fread(lsize,sizeof(stdint_t),13,fin);
            error_loc(ir!=13,1,"blk_import_msfld [farchive.c]",
                      "Incorrect read count");

            if (endian==BIG_ENDIAN)
               bswap_int(13,lsize);

            ie=0;
            ie|=((int)(lsize[0])!=nl[0]);
            ie|=((int)(lsize[1])!=nl[1]);
            ie|=((int)(lsize[2])!=nl[2]);
            ie|=((int)(lsize[3])!=nl[3]);
            ie|=((int)(lsize[4])!=bs[0]);
            ie|=((int)(lsize[5])!=bs[1]);
            ie|=((int)(lsize[6])!=bs[2]);
            ie|=((int)(lsize[7])!=bs[3]);
            ie|=((int)(lsize[8])!=bo[0]);
            ie|=((int)(lsize[9])!=bo[1]);
            ie|=((int)(lsize[10])!=bo[2]);
            ie|=((int)(lsize[11])!=bo[3]);
            ie|=((int)(lsize[12])!=n);

            error_loc(ie!=0,1,"blk_import_msfld [farchive.c]",
                      "Unexpected file header data or number of fields");

            ir=fread(snrm,sizeof(double),n,fin);
            error_loc(ir!=n,1,"blk_import_msfld [farchive.c]",
                      "Incorrect read count");

            if (endian==BIG_ENDIAN)
               bswap_double(n,snrm);
         }

         ira=0;

         for (ix=0;ix<(bs[0]*bs[1]*bs[2]);ix++)
         {
            iy=ix;
            x2=iy%bs[2];
            iy/=bs[2];
            x1=iy%bs[1];
            iy/=bs[1];
            x0=iy;

            x0+=bo[0];
            x1+=bo[1];
            x2+=bo[2];

            if (my_rank==ip0)
            {
               ir=fread(gbuf,sizeof(double),n*bs[3],fin);
               ira|=(ir!=(n*bs[3]));

               if (endian==BIG_ENDIAN)
                  bswap_double(n*bs[3],gbuf);
            }

            set_line(ip0,bs[3],x0,x1,x2,bo[3],n,f);
         }

         if (my_rank==ip0)
         {
            error_loc(ira!=0,1,"blk_import_msfld [farchive.c]",
                      "Incorrect read count");
            fclose(fin);
         }
      }

      MPI_Barrier(MPI_COMM_WORLD);
   }

   eps=64.0*DBL_EPSILON;
   ie=0;

   for (i=0;i<n;i++)
   {
      sn1=square_norm(1,f[i]);

      if (my_rank==ip0)
      {
         sn0=snrm[i];
         ie|=(fabs(sn1-sn0)>(eps*(sn0+sn1)));
      }
   }

   error(ie!=0,1,"blk_import_msfld [farchive.c]",
         "Incorrect field square norms");
}
