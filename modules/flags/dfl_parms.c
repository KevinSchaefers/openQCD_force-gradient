
/*******************************************************************************
*
* File dfl_parms.c
*
* Copyright (C) 2009-2013, 2021 Martin Luescher
*
* This software is distributed under the terms of the GNU General Public
* License (GPL)
*
* Deflation parameters.
*
*   dfl_parms_t set_dfl_parms(int *bs,int Ns)
*     Sets the parameters of the deflation subspace. The parameters are
*
*       bs[4]          Sizes of the blocks in DFL_BLOCKS block grid.
*
*       Ns             Number of deflation modes per block (must be
*                      even and non-zero).
*
*     The return value is a structure that contains the above parameters.
*     Note that these parameters can only be set once.
*
*   dfl_parms_t dfl_parms(void)
*     Returns the parameters currently set for the deflation subspace.
*
*   void read_dfl_parms(char *section)
*     Reads the DFL parameters on MPI process 0 from the specified
*     parameter section on stdin. The tags
*
*       bs           <int> <int> <int> <int>
*       Ns           <int>
*
*     must all be present in the section.
*
*   dfl_pro_parms_t set_dfl_pro_parms(int nkv,int nmx,double res,
*                                     int nmx_gcr,double res_gcr)
*     Sets the parameters used when applying the deflation projection in the
*     deflated solver program dfl_sap_gcr(). The parameters are
*
*       nkv            Maximal number of Krylov vectors to be used by the
*                      fgcr4vd() solver for the little Dirac equation before
*                      a restart.
*
*       nmx            Maximal total number of Krylov vectors generated by
*                      the fgcr4vd() solver for the little Dirac equation.
*
*       res            Required relative residue when solving the little
*                      Dirac equation.
*
*       nmx_gcr        Maximal number of Krylov vectors to be used by the
*                      gcr4v() preconditioner of the little Dirac equation.
*
*       res_gcr        Desired relative residue to be reached by the gcr4v()
*                      preconditioner.
*
*     The return value is a structure that contains the above parameters.
*
*   dfl_pro_parms_t dfl_pro_parms(void)
*     Returns the parameters currently set for the deflation projectors in
*     the deflated solver program dfl_sap_gcr().
*
*   void read_dfl_pro_parms(char *section)
*     Reads the deflation-projection parameters on MPI process 0 from the
*     specified parameter section on stdin. The tags
*
*       nkv          <int>
*       nmx          <int>
*       res          <double>
*       nmx_gcr      <int>
*       res_gcr      <double>
*
*     must all be present in the section.
*
*   dfl_gen_parms_t set_dfl_gen_parms(double kappa,double mu,
*                                     int ninv,int nmr,int ncy,
*                                     int nkv,int nmx,double res)
*     Sets the parameters of the inverse iteration procedure that generates
*     the deflation subspace. The parameters are
*
*       kappa          Hopping parameter of the Dirac operator.
*
*       mu             Twisted mass parameter.
*
*       ninv           Total number of inverse iteration steps (ninv>=4).
*
*       nmr            Number of block minimal residual iterations to be
*                      used when the SAP smoother is applied.
*
*       ncy            Number of SAP cycles per inverse iteration.
*
*     The return value is a structure that contains the above parameters and
*     the bare mass m0 that corresponds to the hopping parameter kappa.
*
*   dfl_gen_parms_t dfl_gen_parms(void)
*     Returns the parameters currently set for the generation of the deflation
*     subspace plus the corresponding bare mass m0.
*
*   void read_dfl_gen_parms(char *section)
*     Reads the deflation subspace generation parameters on MPI process 0
*     from the specified parameter section on stdin. The tags
*
*       kappa        <double>
*       mu           <double>
*       ninv         <int>
*       nmr          <int>
*       ncy          <int>
*
*     must all be present in the section.
*
*   dfl_upd_parms_t set_dfl_upd_parms(double dtau,int nsm)
*     Sets the parameters of the deflation subspace update scheme. The
*     parameters are
*
*       dtau           Molecular-dynamics time separation between
*                      updates of the deflation subspace.
*
*       nsm            Number of deflated smoothing interations to be
*                      applied when the subspace is updated.
*
*     The return value is a structure that contains the above parameters.
*
*   dfl_upd_parms_t dfl_upd_parms(void)
*     Returns the parameters currently set for the deflation subspace
*     update scheme.
*
*   void read_dfl_upd_parms(char *section)
*     Reads the deflation subspace update parameters on MPI process 0
*     from the specified parameter section on stdin. The tags
*
*       dtau         <double>
*       nsm          <int>
*
*     must all be present in the section.
*
*   void print_dfl_parms(int ipr)
*     Prints the parameters of the deflation subspace, the projectors, the
*     subspace generation algorithm and the update scheme to stdout on MPI
*     process 0. The update scheme is omitted if ipr=0.
*
*   void write_dfl_parms(FILE *fdat)
*     Writes the parameters of the deflation subspace, the projectors, the
*     subspace generation algorithm and the update scheme to the file fdat
*     on MPI process 0.
*
*   void check_dfl_parms(FILE *fdat)
*     Compares the parameters of the deflation subspace, the projectors the
*     subspace generation algorithm and the update scheme with the values
*     stored on the file fdat on MPI process 0, assuming the latter were
*     written to the file by the program write_dfl_parms().
*
* To ensure the consistency of the data base, the parameters must be set
* simultaneously on all processes. The types dfl_parms_t, ... are defined
* in the file flags.h.
*
*******************************************************************************/

#define DFL_PARMS_C

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include "mpi.h"
#include "utils.h"
#include "flags.h"
#include "global.h"

static dfl_parms_t dfl={{0,0,0,0},0};
static dfl_pro_parms_t dfl_pro={0,0,0,1.0,1.0};
static dfl_gen_parms_t dfl_gen={0,0,0,0.0,DBL_MAX,0.0};
static dfl_upd_parms_t dfl_upd={0,0.0};


static void check_block_size(int *bs)
{
   int n0,n1,n2,n3;

   error_root((bs[0]<4)||(bs[0]>L0)||(bs[1]<4)||(bs[1]>L1)||
              (bs[2]<4)||(bs[2]>L2)||(bs[3]<4)||(bs[3]>L3),1,
              "check_block_size [dfl_parms.c]",
              "Block sizes are out of range");

   error_root((bs[0]%2)||(bs[1]%2)||(bs[2]%2)||(bs[3]%2),1,
              "check_block_size [dfl_parms.c]",
              "Block sizes must be even");

   error_root((L0%bs[0])||(L1%bs[1])||(L2%bs[2])||(L3%bs[3]),1,
              "check_block_size [dfl_parms.c]",
              "Blocks do not divide the local lattice");

   n0=L0/bs[0];
   n1=L1/bs[1];
   n2=L2/bs[2];
   n3=L3/bs[3];

   error_root(((NPROC0*n0)%2)||((NPROC1*n1)%2)||
              ((NPROC2*n2)%2)||((NPROC3*n3)%2),1,
              "check_block_size [dfl_parms.c]",
              "There must be an even number of blocks in each direction");

   error_root((n0*n1*n2*n3)%(2*NTHREAD),1,
              "check_block_size [dfl_parms.c]",
              "The number of blocks in the local lattice must be an even\n"
              "multiple of NTHREAD");
}


dfl_parms_t set_dfl_parms(int *bs,int Ns)
{
   int iprms[5];

   if (NPROC>1)
   {
      iprms[0]=bs[0];
      iprms[1]=bs[1];
      iprms[2]=bs[2];
      iprms[3]=bs[3];
      iprms[4]=Ns;

      MPI_Bcast(iprms,5,MPI_INT,0,MPI_COMM_WORLD);

      error((iprms[0]!=bs[0])||(iprms[1]!=bs[1])||(iprms[2]!=bs[2])||
            (iprms[3]!=bs[3])||(iprms[4]!=Ns),1,
            "set_dfl_parms [dfl_parms.c]","Parameters are not global");
   }

   error_root((dfl.Ns>0)&&((bs[0]!=dfl.bs[0])||(bs[1]!=dfl.bs[1])||
                           (bs[2]!=dfl.bs[2])||(bs[3]!=dfl.bs[3])||
                           (Ns!=dfl.Ns)),1,
              "set_dfl_parms [dfl_parms.c]","bs[4] and Ns may be set only once");

   check_block_size(bs);
   error_root((Ns<2)||(Ns&0x1),1,"set_dfl_parms [dfl_parms.c]",
              "Improper value of Ns");

   dfl.bs[0]=bs[0];
   dfl.bs[1]=bs[1];
   dfl.bs[2]=bs[2];
   dfl.bs[3]=bs[3];
   dfl.Ns=Ns;

   return dfl;
}


dfl_parms_t dfl_parms(void)
{
   return dfl;
}


void read_dfl_parms(char *section)
{
   int my_rank,bs[4],Ns;

   MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);

   if (my_rank==0)
   {
      find_section(section);

      read_iprms("bs",4,bs);
      read_line("Ns","%d",&Ns);
   }

   if (NPROC>1)
   {
      MPI_Bcast(bs,4,MPI_INT,0,MPI_COMM_WORLD);
      MPI_Bcast(&Ns,1,MPI_INT,0,MPI_COMM_WORLD);
   }

   (void)(set_dfl_parms(bs,Ns));
}


dfl_pro_parms_t set_dfl_pro_parms(int nkv,int nmx,double res,
                                  int nmx_gcr,double res_gcr)
{
   int iprms[3];
   double dprms[2];

   if (NPROC>1)
   {
      iprms[0]=nkv;
      iprms[1]=nmx;
      iprms[2]=nmx_gcr;

      dprms[0]=res;
      dprms[1]=res_gcr;

      MPI_Bcast(iprms,3,MPI_INT,0,MPI_COMM_WORLD);
      MPI_Bcast(dprms,2,MPI_DOUBLE,0,MPI_COMM_WORLD);

      error((iprms[0]!=nkv)||(iprms[1]!=nmx)||(iprms[2]!=nmx_gcr)||
            (dprms[0]!=res)||(dprms[1]!=res_gcr),1,
            "set_dfl_pro_parms [dfl_parms.c]","Parameters are not global");
   }

   error_root((nkv<2)||(nmx<1)||(res<=DBL_EPSILON)||
              (nmx_gcr<2)||(res_gcr<=FLT_EPSILON),1,
              "set_dfl_pro_parms [dfl_parms.c]","Improper parameter values");

   dfl_pro.nkv=nkv;
   dfl_pro.nmx=nmx;
   dfl_pro.nmx_gcr=nmx_gcr;
   dfl_pro.res=res;
   dfl_pro.res_gcr=res_gcr;

   return dfl_pro;
}


dfl_pro_parms_t dfl_pro_parms(void)
{
   return dfl_pro;
}


void read_dfl_pro_parms(char *section)
{
   int my_rank,nkv,nmx,nmx_gcr;
   double res,res_gcr;

   MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);

   if (my_rank==0)
   {
      find_section(section);

      read_line("nkv","%d",&nkv);
      read_line("nmx","%d",&nmx);
      read_line("res","%lf",&res);
      read_line("nmx_gcr","%d",&nmx_gcr);
      read_line("res_gcr","%lf",&res_gcr);
   }

   if (NPROC>1)
   {
      MPI_Bcast(&nkv,1,MPI_INT,0,MPI_COMM_WORLD);
      MPI_Bcast(&nmx,1,MPI_INT,0,MPI_COMM_WORLD);
      MPI_Bcast(&res,1,MPI_DOUBLE,0,MPI_COMM_WORLD);
      MPI_Bcast(&nmx_gcr,1,MPI_INT,0,MPI_COMM_WORLD);
      MPI_Bcast(&res_gcr,1,MPI_DOUBLE,0,MPI_COMM_WORLD);
   }

   (void)(set_dfl_pro_parms(nkv,nmx,res,nmx_gcr,res_gcr));
}


dfl_gen_parms_t set_dfl_gen_parms(double kappa,double mu,
                                  int ninv,int nmr,int ncy)
{
   int iprms[3];
   double dprms[2];

   if (NPROC>1)
   {
      iprms[0]=ninv;
      iprms[1]=nmr;
      iprms[2]=ncy;

      dprms[0]=kappa;
      dprms[1]=mu;

      MPI_Bcast(iprms,3,MPI_INT,0,MPI_COMM_WORLD);
      MPI_Bcast(dprms,2,MPI_DOUBLE,0,MPI_COMM_WORLD);

      error((iprms[0]!=ninv)||(iprms[1]!=nmr)||(iprms[2]!=ncy)||
            (dprms[0]!=kappa)||(dprms[1]!=mu),1,
            "set_dfl_gen_parms [dfl_parms.c]","Parameters are not global");
   }

   error_root((ninv<4)||(nmr<1)||(ncy<1)||(kappa<0.0),1,
              "set_dfl_gen_parms [dfl_parms.c]","Parameters are out of range");

   dfl_gen.ninv=ninv;
   dfl_gen.nmr=nmr;
   dfl_gen.ncy=ncy;

   dfl_gen.kappa=kappa;
   dfl_gen.mu=mu;

   if (kappa!=0.0)
      dfl_gen.m0=1.0/(2.0*kappa)-4.0;
   else
      dfl_gen.m0=DBL_MAX;

   return dfl_gen;
}


dfl_gen_parms_t dfl_gen_parms(void)
{
   return dfl_gen;
}


void read_dfl_gen_parms(char *section)
{
   int my_rank,ninv,nmr,ncy;
   double kappa,mu;

   MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);

   if (my_rank==0)
   {
      find_section(section);

      read_line("kappa","%lf",&kappa);
      read_line("mu","%lf",&mu);
      read_line("ninv","%d",&ninv);
      read_line("nmr","%d",&nmr);
      read_line("ncy","%d",&ncy);
   }

   if (NPROC>1)
   {
      MPI_Bcast(&kappa,1,MPI_DOUBLE,0,MPI_COMM_WORLD);
      MPI_Bcast(&mu,1,MPI_DOUBLE,0,MPI_COMM_WORLD);
      MPI_Bcast(&ninv,1,MPI_INT,0,MPI_COMM_WORLD);
      MPI_Bcast(&nmr,1,MPI_INT,0,MPI_COMM_WORLD);
      MPI_Bcast(&ncy,1,MPI_INT,0,MPI_COMM_WORLD);
   }

   (void)(set_dfl_gen_parms(kappa,mu,ninv,nmr,ncy));
}


dfl_upd_parms_t set_dfl_upd_parms(double dtau,int nsm)
{
   int iprms[1];
   double dprms[1];

   if (NPROC>1)
   {
      iprms[0]=nsm;
      dprms[0]=dtau;

      MPI_Bcast(iprms,1,MPI_INT,0,MPI_COMM_WORLD);
      MPI_Bcast(dprms,1,MPI_DOUBLE,0,MPI_COMM_WORLD);

      error((iprms[0]!=nsm)||(dprms[0]!=dtau),1,
            "set_dfl_upd_parms [dfl_parms.c]","Parameters are not global");
   }

   error_root((dtau<0.0)||(nsm<0),1,
              "set_dfl_upd_parms [dfl_parms.c]","Improper parameter values");

   dfl_upd.dtau=dtau;
   dfl_upd.nsm=nsm;

   return dfl_upd;
}


dfl_upd_parms_t dfl_upd_parms(void)
{
   return dfl_upd;
}


void read_dfl_upd_parms(char *section)
{
   int my_rank,nsm;
   double dtau;

   MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);

   if (my_rank==0)
   {
      find_section(section);

      read_line("dtau","%lf",&dtau);
      read_line("nsm","%d",&nsm);
   }

   if (NPROC>1)
   {
      MPI_Bcast(&dtau,1,MPI_DOUBLE,0,MPI_COMM_WORLD);
      MPI_Bcast(&nsm,1,MPI_INT,0,MPI_COMM_WORLD);
   }

   (void)(set_dfl_upd_parms(dtau,nsm));
}


void print_dfl_parms(int ipr)
{
   int my_rank,n;

   MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);

   if (my_rank==0)
   {
      printf("Deflation subspace:\n");
      printf("bs = %d %d %d %d\n",dfl.bs[0],dfl.bs[1],dfl.bs[2],dfl.bs[3]);
      printf("Ns = %d\n\n",dfl.Ns);

      printf("Deflation projection:\n");
      printf("nkv = %d\n",dfl_pro.nkv);
      printf("nmx = %d\n",dfl_pro.nmx);
      printf("res = %.1e\n",dfl_pro.res);
      printf("nmx_gcr = %d\n",dfl_pro.nmx_gcr);
      printf("res_gcr = %.1e\n\n",dfl_pro.res_gcr);

      printf("Deflation subspace generation:\n");
      n=fdigits(dfl_gen.kappa);
      printf("kappa = %.*f\n",IMAX(n,6),dfl_gen.kappa);
      n=fdigits(dfl_gen.mu);
      printf("mu = %.*f\n",IMAX(n,1),dfl_gen.mu);
      printf("ninv = %d\n",dfl_gen.ninv);
      printf("nmr = %d\n",dfl_gen.nmr);
      printf("ncy = %d\n\n",dfl_gen.ncy);

      if (ipr)
      {
         printf("Deflation subspace update scheme:\n");
         n=fdigits(dfl_upd.dtau);
         printf("dtau = %.*f\n",IMAX(n,1),dfl_upd.dtau);
         printf("nsm = %d\n\n",dfl_upd.nsm);
      }
   }
}


void write_dfl_parms(FILE *fdat)
{
   int my_rank,endian;
   int i,iw;
   stdint_t istd[12];
   double dstd[5];

   MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);
   endian=endianness();

   if (my_rank==0)
   {
      for (i=0;i<4;i++)
         istd[i]=(stdint_t)(dfl.bs[i]);

      istd[4]=(stdint_t)(dfl.Ns);
      istd[5]=(stdint_t)(dfl_pro.nkv);
      istd[6]=(stdint_t)(dfl_pro.nmx);
      istd[7]=(stdint_t)(dfl_pro.nmx_gcr);
      istd[8]=(stdint_t)(dfl_gen.ninv);
      istd[9]=(stdint_t)(dfl_gen.nmr);
      istd[10]=(stdint_t)(dfl_gen.ncy);
      istd[11]=(stdint_t)(dfl_upd.nsm);

      dstd[0]=dfl_pro.res;
      dstd[1]=dfl_pro.res_gcr;
      dstd[2]=dfl_gen.kappa;
      dstd[3]=dfl_gen.mu;
      dstd[4]=dfl_upd.dtau;

      if (endian==BIG_ENDIAN)
      {
         bswap_int(12,istd);
         bswap_double(5,dstd);
      }

      iw=fwrite(istd,sizeof(stdint_t),12,fdat);
      iw+=fwrite(dstd,sizeof(double),5,fdat);
      error_root(iw!=17,1,"write_dfl_parms [dfl_parms.c]",
                 "Incorrect write count");
   }
}


void check_dfl_parms(FILE *fdat)
{
   int my_rank,endian;
   int i,ir,ie;
   stdint_t istd[12];
   double dstd[5];

   MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);
   endian=endianness();

   if (my_rank==0)
   {
      ir=fread(istd,sizeof(stdint_t),12,fdat);
      ir+=fread(dstd,sizeof(double),5,fdat);
      error_root(ir!=17,1,"check_dfl_parms [dfl_parms.c]",
                 "Incorrect read count");

      if (endian==BIG_ENDIAN)
      {
         bswap_int(12,istd);
         bswap_double(5,dstd);
      }

      ie=0;

      for (i=0;i<4;i++)
         ie|=(istd[i]!=(stdint_t)(dfl.bs[i]));

      ie|=(istd[4]!=(stdint_t)(dfl.Ns));
      ie|=(istd[5]!=(stdint_t)(dfl_pro.nkv));
      ie|=(istd[6]!=(stdint_t)(dfl_pro.nmx));
      ie|=(istd[7]!=(stdint_t)(dfl_pro.nmx_gcr));
      ie|=(istd[8]!=(stdint_t)(dfl_gen.ninv));
      ie|=(istd[9]!=(stdint_t)(dfl_gen.nmr));
      ie|=(istd[10]!=(stdint_t)(dfl_gen.ncy));
      ie|=(istd[11]!=(stdint_t)(dfl_upd.nsm));

      ie|=(dstd[0]!=dfl_pro.res);
      ie|=(dstd[1]!=dfl_pro.res_gcr);
      ie|=(dstd[2]!=dfl_gen.kappa);
      ie|=(dstd[3]!=dfl_gen.mu);
      ie|=(dstd[4]!=dfl_upd.dtau);

      error_root(ie!=0,1,"check_dfl_parms [dfl_parms.c]",
                 "Parameters do not match");
   }
}
